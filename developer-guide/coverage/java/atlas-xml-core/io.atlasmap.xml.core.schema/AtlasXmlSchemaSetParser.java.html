<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AtlasXmlSchemaSetParser.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Coverage Report</a> &gt; <a href="../index.html" class="el_bundle">atlas-xml-core</a> &gt; <a href="index.source.html" class="el_package">io.atlasmap.xml.core.schema</a> &gt; <span class="el_source">AtlasXmlSchemaSetParser.java</span></div><h1>AtlasXmlSchemaSetParser.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 20 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.atlasmap.xml.core.schema;

import static io.atlasmap.xml.core.AtlasXmlConstants.NS_PREFIX_SCHEMASET;
import static io.atlasmap.xml.core.AtlasXmlConstants.NS_PREFIX_XMLSCHEMA;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.util.LinkedList;
import java.util.List;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;

import com.sun.xml.xsom.XSSchemaSet;
import com.sun.xml.xsom.parser.XSOMParser;
import com.sun.xml.xsom.util.DomAnnotationParserFactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import io.atlasmap.api.AtlasException;
import io.atlasmap.xml.core.AtlasXmlNamespaceContext;

public class AtlasXmlSchemaSetParser {

<span class="fc" id="L63">    private static final Logger LOG = LoggerFactory.getLogger(AtlasXmlSchemaSetParser.class);</span>
    private ClassLoader classLoader;
    private AtlasXmlNamespaceContext namespaceContext;
    private String rootNamespace;
    private SAXParserFactory saxParserFactory;
    private Transformer transformer;
    private DocumentBuilder documentBuilder;

<span class="fc" id="L71">    public AtlasXmlSchemaSetParser(ClassLoader cl) throws AtlasException {</span>
<span class="fc" id="L72">        this.classLoader = cl;</span>
<span class="fc" id="L73">        this.namespaceContext = new AtlasXmlNamespaceContext();</span>
<span class="fc" id="L74">        this.saxParserFactory = SAXParserFactory.newInstance();</span>
        try {
<span class="fc" id="L76">            this.transformer = TransformerFactory.newInstance().newTransformer();</span>
<span class="fc" id="L77">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="fc" id="L78">            dbf.setNamespaceAware(true);</span>
<span class="fc" id="L79">            this.documentBuilder = dbf.newDocumentBuilder();</span>
<span class="nc" id="L80">        } catch (Exception e) {</span>
<span class="nc" id="L81">            throw new AtlasException(e);</span>
<span class="fc" id="L82">        }</span>
<span class="fc" id="L83">    }</span>

    /**
     * Parse single XML Schema or SchemaSet which contains multiple XML Schema and
     * build a {@link XSSchemaSet}.
     * @param root DOM {@link Document} instance of XML Schema
     * @return parsed {@link XSSchemaSet}
     */
    public XSSchemaSet parse(Document doc) throws AtlasException {
<span class="fc" id="L92">        XSOMParser xsomParser = createXSOMParser();</span>
<span class="fc" id="L93">        parseInternal(doc, n -&gt; {</span>
            try {
<span class="fc" id="L95">                xsomParser.parse(toInputStream(n));</span>
<span class="fc" id="L96">            } catch (Exception e) {</span>
<span class="fc" id="L97">                throw new AtlasException(e);</span>
<span class="fc" id="L98">            }</span>
<span class="fc" id="L99">        });</span>
        try {
<span class="fc" id="L101">            return xsomParser.getResult();</span>
<span class="nc" id="L102">        } catch (Exception e) {</span>
<span class="nc" id="L103">            throw new AtlasException(e);</span>
        }
    }

    /**
     * Parse XML Schema or SchemaSet which contains multiple XML Schema and
     * build a {@link XSSchemaSet}.
     * @param in {@link InputStream} of XML Schema document
     * @return parsed {@link XSSchemaSet}
     */
    public XSSchemaSet parse(InputStream in) throws AtlasException {
        try {
<span class="fc" id="L115">            Document doc = this.documentBuilder.parse(in);</span>
<span class="fc" id="L116">            return parse(doc);</span>
<span class="fc" id="L117">        } catch (Exception e) {</span>
<span class="fc" id="L118">            throw new AtlasException(e);</span>
        }
    }

    /**
     * Parse single XML Schema or SchemaSet which contains multiple XML Schema and
     * build a {@link Schema}.
     * @return
     * @throws AtlasException
     */
    public Schema createSchema(InputStream in) throws AtlasException {
<span class="fc" id="L129">        SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);</span>
<span class="fc" id="L130">        List&lt;Source&gt; schemaSources = new LinkedList&lt;&gt;();</span>
        Document doc;
        try {
<span class="fc" id="L133">            doc = this.documentBuilder.parse(in);</span>
<span class="fc" id="L134">            parseInternal(doc, n -&gt; {</span>
<span class="fc" id="L135">                DOMSource s = new DOMSource(n);</span>
<span class="fc" id="L136">                schemaSources.add(s);</span>
<span class="fc" id="L137">            });</span>
<span class="fc" id="L138">            factory.setErrorHandler(new NoopErrorHandler());</span>
<span class="fc" id="L139">            return factory.newSchema(schemaSources.toArray(new Source[0]));</span>
<span class="nc" id="L140">        } catch (AtlasException e) {</span>
<span class="nc" id="L141">            throw e;</span>
<span class="nc" id="L142">        } catch (Exception e2) {</span>
<span class="nc" id="L143">            throw new AtlasException(e2);</span>
        }
    }

    public void setNamespaceContext(AtlasXmlNamespaceContext nsc) {
<span class="nc" id="L148">        this.namespaceContext = nsc;</span>
<span class="nc" id="L149">    }</span>

    public AtlasXmlNamespaceContext getNamespaceContext() {
<span class="fc" id="L152">        return this.namespaceContext;</span>
    }

    public void setRootNamespace(String rootns) {
<span class="nc" id="L156">        this.rootNamespace = rootns;</span>
<span class="nc" id="L157">    }</span>

    public String getRootNamespace() {
<span class="fc" id="L160">        return this.rootNamespace;</span>
    }

    private String getTargetNamespace(Node n) {
<span class="fc" id="L164">        NamedNodeMap attributes = n.getAttributes();</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (attributes == null) {</span>
<span class="nc" id="L166">            return &quot;&quot;;</span>
        }
<span class="fc" id="L168">        Attr tns = (Attr) attributes.getNamedItem(&quot;targetNamespace&quot;);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        return tns != null ? tns.getValue() : &quot;&quot;;</span>
    }

    @FunctionalInterface
    private interface ParserCallback {
        void addSchema(Node n) throws AtlasException;
    }

<span class="fc" id="L177">    private class NoopErrorHandler implements ErrorHandler {</span>

        @Override
        public void warning(SAXParseException e) throws SAXException {
<span class="nc bnc" id="L181" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L182">                LOG.debug(&quot;warning&quot;, e);</span>
            }
<span class="nc" id="L184">        }</span>

        @Override
        public void error(SAXParseException e) throws SAXException {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L189">                LOG.debug(&quot;error&quot;, e);</span>
            }
<span class="fc" id="L191">        }</span>

        @Override
        public void fatalError(SAXParseException e) throws SAXException {
<span class="nc bnc" id="L195" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L196">                LOG.debug(&quot;fatalError&quot;, e);</span>
            }
<span class="nc" id="L198">        }</span>
        
    }

    private void parseInternal(Document doc, ParserCallback callback) throws AtlasException {
        try {
<span class="fc" id="L204">            Element root = doc.getDocumentElement();</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">            if (&quot;SchemaSet&quot;.equals(root.getLocalName())) {</span>
<span class="fc" id="L206">                XPath xpath = XPathFactory.newInstance().newXPath();</span>
<span class="fc" id="L207">                xpath.setNamespaceContext(this.namespaceContext);</span>
<span class="fc" id="L208">                NodeList subSchemas = (NodeList) xpath</span>
<span class="fc" id="L209">                        .evaluate(String.format(&quot;/%s:SchemaSet/%s:AdditionalSchemas/%s:schema&quot;, NS_PREFIX_SCHEMASET,</span>
                                NS_PREFIX_SCHEMASET, NS_PREFIX_XMLSCHEMA), root, XPathConstants.NODESET);
<span class="fc bfc" id="L211" title="All 2 branches covered.">                for (int i = 0; i &lt; subSchemas.getLength(); i++) {</span>
<span class="fc" id="L212">                    Element e = (Element) subSchemas.item(i);</span>
<span class="fc" id="L213">                    inheritNamespaces(e, false);</span>
<span class="fc" id="L214">                    callback.addSchema(e);</span>
                }

<span class="fc" id="L217">                Element rootSchema = (Element) xpath.evaluate(</span>
<span class="fc" id="L218">                        String.format(&quot;/%s:SchemaSet/%s:schema&quot;, NS_PREFIX_SCHEMASET, NS_PREFIX_XMLSCHEMA), root,</span>
                        XPathConstants.NODE);
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">                if (rootSchema == null) {</span>
<span class="nc" id="L221">                    throw new AtlasException(</span>
                            &quot;The root schema '/SchemaSet/schema' must be specified once and only once&quot;);
                }
<span class="fc" id="L224">                this.rootNamespace = getTargetNamespace(rootSchema);</span>
<span class="pc bpc" id="L225" title="1 of 4 branches missed.">                if (this.rootNamespace != null &amp;&amp; !this.rootNamespace.isEmpty()) {</span>
<span class="fc" id="L226">                    this.namespaceContext.add(&quot;tns&quot;, this.rootNamespace);</span>
                }
<span class="fc" id="L228">                inheritNamespaces(rootSchema, true);</span>
<span class="fc" id="L229">                callback.addSchema(rootSchema);</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">            } else if (&quot;schema&quot;.equals(root.getLocalName())) {</span>
<span class="fc" id="L231">                callback.addSchema(root);</span>
<span class="fc" id="L232">                this.rootNamespace = getTargetNamespace(root);</span>
<span class="pc bpc" id="L233" title="1 of 4 branches missed.">                if (this.rootNamespace != null &amp;&amp; !this.rootNamespace.isEmpty()) {</span>
<span class="fc" id="L234">                    this.namespaceContext.add(&quot;tns&quot;, this.rootNamespace);</span>
                }
            } else {
<span class="nc" id="L237">                throw new AtlasException(</span>
<span class="nc" id="L238">                        String.format(&quot;Unsupported document element '%s': root element must be 'schema' or 'SchemaSet'&quot;,</span>
<span class="nc" id="L239">                                root.getLocalName()));</span>
            }
<span class="fc" id="L241">        } catch (Exception e) {</span>
<span class="fc" id="L242">            throw new AtlasException(e);</span>
<span class="fc" id="L243">        }</span>
<span class="fc" id="L244">    }</span>

    private XSOMParser createXSOMParser() {
<span class="fc" id="L247">        XSOMParser parser = new XSOMParser(this.saxParserFactory);</span>
<span class="fc" id="L248">        parser.setEntityResolver(new XSOMClasspathEntityResolver(this.classLoader));</span>
<span class="fc" id="L249">        parser.setAnnotationParser(new DomAnnotationParserFactory());</span>
<span class="fc" id="L250">        parser.setErrorHandler(new XSOMErrorHandler());</span>
<span class="fc" id="L251">        return parser;</span>
    }

    private void inheritNamespaces(Element element, boolean updateContext) {
<span class="fc" id="L255">        Node target = element.getParentNode();</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">        while (target != null) {</span>
<span class="fc" id="L257">            NamedNodeMap attributes = target.getAttributes();</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">            if (attributes != null) {</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">                for (int i = 0; i &lt; attributes.getLength(); i++) {</span>
<span class="fc" id="L260">                    Attr attr = (Attr) attributes.item(i);</span>
<span class="pc bpc" id="L261" title="2 of 4 branches missed.">                    if (&quot;xmlns&quot;.equals(attr.getPrefix()) &amp;&amp; !&quot;xmlns&quot;.equals(attr.getLocalName())) {</span>
<span class="fc" id="L262">                        element.setAttribute(attr.getName(), attr.getValue());</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">                        if (updateContext) {</span>
<span class="fc" id="L264">                            namespaceContext.add(attr.getLocalName(), attr.getValue());</span>
                        }
                    }
                }
            }
<span class="fc" id="L269">            target = target.getParentNode();</span>
<span class="fc" id="L270">        }</span>
<span class="fc" id="L271">    }</span>

    private ByteArrayInputStream toInputStream(Node n) throws Exception {
<span class="fc" id="L274">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L275">        this.transformer.transform(new DOMSource(n), new StreamResult(baos));</span>
<span class="fc" id="L276">        byte[] output = baos.toByteArray();</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (LOG.isTraceEnabled()) {</span>
<span class="fc" id="L278">            LOG.trace(&quot;&gt;&gt;&gt; {}&quot;, new String(output));</span>
        }
<span class="fc" id="L280">        return new ByteArrayInputStream(output);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>