<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BaseModuleValidationService.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Coverage Report</a> &gt; <a href="../index.html" class="el_bundle">atlas-core</a> &gt; <a href="index.source.html" class="el_package">io.atlasmap.core.validate</a> &gt; <span class="el_source">BaseModuleValidationService.java</span></div><h1>BaseModuleValidationService.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2017 Red Hat, Inc.
 * &lt;p&gt;
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * &lt;p&gt;
 * http://www.apache.org/licenses/LICENSE-2.0
 * &lt;p&gt;
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.atlasmap.core.validate;

import java.util.ArrayList;
import java.util.List;

import io.atlasmap.api.AtlasValidationService;
import io.atlasmap.core.DefaultAtlasCollectionHelper;
import io.atlasmap.core.DefaultAtlasConversionService;
import io.atlasmap.core.DefaultAtlasFieldActionService;
import io.atlasmap.spi.AtlasConversionService;
import io.atlasmap.spi.AtlasFieldActionService;
import io.atlasmap.spi.AtlasModuleDetail;
import io.atlasmap.spi.AtlasModuleMode;
import io.atlasmap.spi.FieldDirection;
import io.atlasmap.v2.AtlasMapping;
import io.atlasmap.v2.BaseMapping;
import io.atlasmap.v2.DataSource;
import io.atlasmap.v2.Field;
import io.atlasmap.v2.FieldGroup;
import io.atlasmap.v2.FieldType;
import io.atlasmap.v2.Mapping;
import io.atlasmap.v2.MappingType;
import io.atlasmap.v2.Validation;
import io.atlasmap.v2.ValidationScope;
import io.atlasmap.v2.ValidationStatus;

public abstract class BaseModuleValidationService&lt;T extends Field&gt; implements AtlasValidationService {

    private AtlasConversionService conversionService;
    private AtlasFieldActionService fieldActionService;
    private DefaultAtlasCollectionHelper collectionHelper;
    private AtlasModuleMode mode;
    private String docId;
    private MappingFieldPairValidator mappingFieldPairValidator;

<span class="nc" id="L51">    public BaseModuleValidationService() {</span>
<span class="nc" id="L52">        this.conversionService = DefaultAtlasConversionService.getInstance();</span>
<span class="nc" id="L53">        this.fieldActionService = DefaultAtlasFieldActionService.getInstance();</span>
<span class="nc" id="L54">        this.collectionHelper = new DefaultAtlasCollectionHelper(this.fieldActionService);</span>
<span class="nc" id="L55">        init();</span>
<span class="nc" id="L56">    }</span>

<span class="fc" id="L58">    public BaseModuleValidationService(AtlasConversionService conversionService, AtlasFieldActionService fieldActionService) {</span>
<span class="fc" id="L59">        this.conversionService = conversionService;</span>
<span class="fc" id="L60">        this.fieldActionService = fieldActionService;</span>
<span class="fc" id="L61">        this.collectionHelper = new DefaultAtlasCollectionHelper(fieldActionService);</span>
<span class="fc" id="L62">        init();</span>
<span class="fc" id="L63">    }</span>

    private void init() {
<span class="fc" id="L66">        this.mappingFieldPairValidator = new MappingFieldPairValidator(this);</span>
<span class="fc" id="L67">    }</span>

    public void setMode(AtlasModuleMode mode) {
<span class="fc" id="L70">        this.mode = mode;</span>
<span class="fc" id="L71">    }</span>

    public AtlasModuleMode getMode() {
<span class="fc" id="L74">        return mode;</span>
    }

    public void setDocId(String docId) {
<span class="fc" id="L78">        this.docId = docId;</span>
<span class="fc" id="L79">    }</span>

    public String getDocId() {
<span class="fc" id="L82">        return this.docId;</span>
    }

    protected abstract AtlasModuleDetail getModuleDetail();

    @Override
    public List&lt;Validation&gt; validateMapping(AtlasMapping mapping) {
<span class="fc" id="L89">        List&lt;Validation&gt; validations = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (getMode() == AtlasModuleMode.UNSET) {</span>
<span class="nc" id="L91">            Validation validation = new Validation();</span>
<span class="nc" id="L92">            validation.setMessage(String.format(</span>
                    &quot;No mode specified for %s/%s, skipping module validations&quot;,
<span class="nc" id="L94">                    this.getModuleDetail().name(), this.getClass().getSimpleName()));</span>
        }

<span class="pc bpc" id="L97" title="3 of 6 branches missed.">        if (mapping != null &amp;&amp; mapping.getMappings() != null &amp;&amp; mapping.getMappings().getMapping() != null</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">                &amp;&amp; !mapping.getMappings().getMapping().isEmpty()) {</span>
<span class="fc" id="L99">            validateMappingEntries(mapping.getMappings().getMapping(), validations);</span>
        }

<span class="fc" id="L102">        boolean found = false;</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        for (DataSource ds : mapping.getDataSource()) {</span>
<span class="pc bpc" id="L104" title="1 of 4 branches missed.">            if (ds.getUri() != null &amp;&amp; ds.getUri().startsWith(getModuleDetail().uri())) {</span>
<span class="fc" id="L105">                found = true;</span>
<span class="fc" id="L106">                break;</span>
            }
<span class="fc" id="L108">        }</span>

<span class="fc bfc" id="L110" title="All 2 branches covered.">        if (!found) {</span>
<span class="fc" id="L111">            Validation validation = new Validation();</span>
<span class="fc" id="L112">            validation.setScope(ValidationScope.DATA_SOURCE);</span>
<span class="fc" id="L113">            validation.setMessage(String.format(&quot;No DataSource with '%s' uri specified&quot;, getModuleDetail().uri()));</span>
<span class="fc" id="L114">            validation.setStatus(ValidationStatus.ERROR);</span>
<span class="fc" id="L115">            validations.add(validation);</span>
        }

<span class="fc" id="L118">        return validations;</span>
    }

    protected void validateMappingEntries(List&lt;BaseMapping&gt; mappings, List&lt;Validation&gt; validations) {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for (BaseMapping fieldMapping : mappings) {</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">            if (fieldMapping.getClass().isAssignableFrom(Mapping.class)</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">                    &amp;&amp; MappingType.SEPARATE.equals(((Mapping) fieldMapping).getMappingType())) {</span>
<span class="fc" id="L125">                validateSeparateMapping((Mapping) fieldMapping, validations);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            } else if (fieldMapping.getClass().isAssignableFrom(Mapping.class)</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">                    &amp;&amp; MappingType.COMBINE.equals(((Mapping) fieldMapping).getMappingType())) {</span>
<span class="fc" id="L128">                validateCombineMapping((Mapping) fieldMapping, validations);</span>
            } else {
<span class="fc bfc" id="L130" title="All 2 branches covered.">                if (fieldMapping instanceof io.atlasmap.v2.Collection) {</span>
<span class="fc" id="L131">                    fieldMapping = ((io.atlasmap.v2.Collection)fieldMapping).getMappings().getMapping().get(0);</span>
                }
<span class="fc" id="L133">                validateMapMapping((Mapping) fieldMapping, validations);</span>
            }
<span class="fc" id="L135">        }</span>
<span class="fc" id="L136">    }</span>

    protected void validateMapMapping(Mapping mapping, List&lt;Validation&gt; validations) {
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (mapping == null</span>
<span class="pc bpc" id="L140" title="2 of 6 branches missed.">                || mapping.getInputField() == null || (mapping.getInputFieldGroup() == null &amp;&amp; mapping.getInputField().size() &lt;= 0)</span>
<span class="pc bpc" id="L141" title="2 of 4 branches missed.">                || mapping.getOutputField() == null || mapping.getOutputField().size() &lt;= 0) {</span>
<span class="nc" id="L142">            return;</span>
        }
<span class="fc" id="L144">        String mappingId = mapping.getId();</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (getMode() == AtlasModuleMode.SOURCE) {</span>
<span class="fc" id="L147">            FieldGroup sourceFieldGroup = mapping.getInputFieldGroup();</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            if (sourceFieldGroup != null) {</span>
<span class="fc" id="L149">                validateFieldGroup(mappingId, sourceFieldGroup, FieldDirection.SOURCE, validations);</span>
            } else {
<span class="fc" id="L151">                List&lt;Field&gt; sourceFields = mapping.getInputField();</span>
<span class="fc" id="L152">                sourceFields.forEach(sourceField -&gt; {</span>
<span class="fc" id="L153">                    validateField(mappingId, null, sourceField, FieldDirection.SOURCE, validations);</span>
<span class="fc" id="L154">                });</span>
            }
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        } else if (getMode() == AtlasModuleMode.TARGET) {</span>
<span class="fc" id="L157">            List&lt;Field&gt; targetFields = mapping.getOutputField();</span>

<span class="fc bfc" id="L159" title="All 4 branches covered.">            if (targetFields.size() == 1 &amp;&amp; Integer.valueOf(0).equals(targetFields.get(0).getIndex())) {</span>
                //The index should not have been set as there's only one item
<span class="fc" id="L161">                targetFields.get(0).setIndex(null);</span>
            }

<span class="fc" id="L164">            int i  = 0;</span>
<span class="fc" id="L165">            List&lt;Field&gt; sourceFields = mapping.getInputField();</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">            for (Field targetField: targetFields) {</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                if (sourceFields.size() &gt; i) {</span>
<span class="fc" id="L168">                    validateField(mappingId, sourceFields.get(i), targetField, FieldDirection.TARGET, validations);</span>
                } else {
<span class="fc" id="L170">                    validateField(mappingId, null, targetField, FieldDirection.TARGET, validations);</span>
                }
<span class="fc" id="L172">                i++;</span>
<span class="fc" id="L173">            }</span>
        }

<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (getMode() == AtlasModuleMode.SOURCE) {</span>
<span class="fc" id="L177">            validateFieldCombinations(mapping, validations);</span>
        }
<span class="fc" id="L179">    }</span>

    protected void validateFieldGroup(String mappingId, FieldGroup fieldGroup, FieldDirection direction, List&lt;Validation&gt; validations) {
<span class="fc" id="L182">        fieldGroup.getField().forEach(f -&gt; {validateField(mappingId, null, f, direction, validations);});</span>
<span class="fc" id="L183">    }</span>

    protected void validateFieldCombinations(Mapping mapping, List&lt;Validation&gt; validations) {
<span class="fc" id="L186">        String mappingId = mapping.getId();</span>
<span class="fc" id="L187">        FieldGroup sourceFieldGroup = mapping.getInputFieldGroup();</span>
<span class="fc" id="L188">        List&lt;Field&gt; sourceFields = mapping.getInputField();</span>
<span class="fc" id="L189">        List&lt;Field&gt; targetFields = mapping.getOutputField();</span>
<span class="pc bpc" id="L190" title="2 of 6 branches missed.">        if (sourceFieldGroup != null || (sourceFields != null &amp;&amp; sourceFields.size() &gt; 1)) {</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">            if (targetFields.size() &gt; 1) {</span>
<span class="nc" id="L192">                Validation validation = new Validation();</span>
<span class="nc" id="L193">                validation.setScope(ValidationScope.MAPPING);</span>
<span class="nc" id="L194">                validation.setId(mappingId);</span>
<span class="nc" id="L195">                validation.setMessage(&quot;Multiple fields can not be selected on both of Source and Target&quot;);</span>
<span class="nc" id="L196">                validation.setStatus(ValidationStatus.ERROR);</span>
<span class="nc" id="L197">                validations.add(validation);</span>
            }
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">            if (sourceFieldGroup != null) {</span>
<span class="fc" id="L200">                mappingFieldPairValidator.validateFieldTypes(validations, mappingId, sourceFieldGroup, targetFields.get(0));</span>
            } else {
<span class="nc" id="L202">                mappingFieldPairValidator.validateFieldTypes(validations, mappingId, sourceFields, targetFields.get(0));</span>
            }
<span class="pc bpc" id="L204" title="1 of 4 branches missed.">        } else if (targetFields != null &amp;&amp; targetFields.size() &gt; 1) {</span>
<span class="fc" id="L205">            mappingFieldPairValidator.validateFieldTypes(validations, mappingId, sourceFields.get(0), targetFields);</span>
        } else {
<span class="fc" id="L207">            mappingFieldPairValidator.validateFieldTypes(validations, mappingId, sourceFields.get(0), targetFields.get(0));</span>
        }
<span class="fc" id="L209">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    protected void validateField(String mappingId, Field sourceField, Field targetField, FieldDirection direction, List&lt;Validation&gt; validations) {
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (targetField == null) {</span>
<span class="nc" id="L214">            return;</span>
        }
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (direction == FieldDirection.TARGET) {</span>
<span class="fc" id="L217">            Integer sourceCollectionCount = null;</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">            if (sourceField != null) {</span>
<span class="fc" id="L219">                sourceCollectionCount = collectionHelper.determineSourceCollectionCount(null, sourceField);</span>
            }

<span class="fc" id="L222">            Integer targetCollectionCount = collectionHelper.determineTargetCollectionCount(targetField);</span>

<span class="fc bfc" id="L224" title="All 2 branches covered.">            if (sourceCollectionCount != null) {</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">                if (sourceCollectionCount &gt; targetCollectionCount) {</span>
<span class="fc" id="L226">                    Validation validation = new Validation();</span>
<span class="fc" id="L227">                    validation.setScope(ValidationScope.MAPPING);</span>
<span class="fc" id="L228">                    validation.setId(mappingId);</span>
<span class="fc" id="L229">                    String message = String.format(</span>
                        &quot;Target [%s] has %s collection(s) on the path, whereas source has %s. Values from the %s rightmost &quot; +
                            &quot;source collections on the path will be added in depth-first order to the rightmost target &quot; +
                            &quot;collection(s) unless transformed explicitly.&quot;,
<span class="fc" id="L233">                        targetField.getPath(), targetCollectionCount, sourceCollectionCount,</span>
<span class="fc" id="L234">                        sourceCollectionCount - targetCollectionCount + 1);</span>
<span class="fc" id="L235">                    validation.setMessage(message);</span>
<span class="fc" id="L236">                    validation.setStatus(ValidationStatus.WARN);</span>
<span class="fc" id="L237">                    validations.add(validation);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                } else if (sourceCollectionCount &lt; targetCollectionCount) {</span>
<span class="fc" id="L239">                    Validation validation = new Validation();</span>
<span class="fc" id="L240">                    validation.setScope(ValidationScope.MAPPING);</span>
<span class="fc" id="L241">                    validation.setId(mappingId);</span>
<span class="fc" id="L242">                    validation.setMessage(String.format(&quot;The 0 index will be used for any extra parent collections in &quot; +</span>
                            &quot;target [%s], since target has %s collections on the path, whereas source has %s.&quot;,
<span class="fc" id="L244">                        targetField.getPath(), targetCollectionCount, sourceCollectionCount));</span>
<span class="fc" id="L245">                    validation.setStatus(ValidationStatus.WARN);</span>
<span class="fc" id="L246">                    validations.add(validation);</span>
                }
            }

        }
<span class="fc bfc" id="L251" title="All 4 branches covered.">        if (getFieldType().isAssignableFrom(targetField.getClass()) &amp;&amp; matchDocIdOrNull(targetField.getDocId())) {</span>
<span class="fc" id="L252">            validateModuleField(mappingId, (T)targetField, direction, validations);</span>
        }
<span class="fc" id="L254">    }</span>

    protected abstract Class&lt;T&gt; getFieldType();

    protected abstract void validateModuleField(String mappingId, T field, FieldDirection direction, List&lt;Validation&gt; validation);

    protected boolean matchDocIdOrNull(String docId) {
<span class="fc bfc" id="L261" title="All 4 branches covered.">        return docId == null || getDocId().equals(docId);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    protected String getFieldName(Field field) {
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L267">            return &quot;null&quot;;</span>
        }
<span class="fc bfc" id="L269" title="All 2 branches covered.">        if (field.getClass().isAssignableFrom(getFieldType())) {</span>
<span class="fc" id="L270">            return getModuleFieldName((T)field);</span>
        }
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (field.getFieldType() != null) {</span>
<span class="fc" id="L273">            return field.getFieldType().name();</span>
        }
<span class="nc" id="L275">        return field.getClass().getName();</span>
    }

    protected abstract String getModuleFieldName(T field);

    protected AtlasConversionService getConversionService() {
<span class="fc" id="L281">        return conversionService;</span>
    }

    protected AtlasFieldActionService getFieldActionService() {
<span class="fc" id="L285">        return fieldActionService;</span>
    }

    protected MappingFieldPairValidator getMappingFieldPairValidator() {
<span class="nc" id="L289">        return mappingFieldPairValidator;</span>
    }

    protected void setMappingFieldPairValidator(MappingFieldPairValidator mfpv) {
<span class="fc" id="L293">        mappingFieldPairValidator = mfpv;</span>
<span class="fc" id="L294">    }</span>

    protected void setConversionService(AtlasConversionService conversionService) {
<span class="nc" id="L297">        this.conversionService = conversionService;</span>
<span class="nc" id="L298">    }</span>

    /*
     * vvv Remove in 2.0 vvv
     */

    @Deprecated
    protected void validateCombineMapping(Mapping mapping, List&lt;Validation&gt; validations) {
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (mapping == null) {</span>
<span class="nc" id="L307">            return;</span>
        }

<span class="fc" id="L310">        List&lt;Field&gt; sourceFields = mapping.getInputField();</span>

<span class="fc" id="L312">        final List&lt;Field&gt; targetFields = mapping.getOutputField();</span>
<span class="pc bpc" id="L313" title="2 of 4 branches missed.">        final Field targetField = (targetFields != null &amp;&amp; !targetFields.isEmpty()) ? targetFields.get(0) : null;</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        if (targetField == null) {</span>
<span class="nc" id="L315">            return;</span>
        }

<span class="fc" id="L318">        String mappingId = mapping.getId();</span>

<span class="pc bpc" id="L320" title="1 of 4 branches missed.">        if (getMode() == AtlasModuleMode.TARGET &amp;&amp; matchDocIdOrNull(targetField.getDocId())) {</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">            if (sourceFields != null) {</span>
                // FIXME Run only for TARGET to avoid duplicate validation...
                // we should convert per module validations to plugin style
<span class="fc bfc" id="L324" title="All 2 branches covered.">                for (Field sourceField : sourceFields) {</span>
<span class="fc" id="L325">                    mappingFieldPairValidator.validateFieldTypes(validations, mappingId, sourceField, targetField);</span>
<span class="fc" id="L326">                }</span>
            }

            // check that the output field is of type String else error
<span class="pc bpc" id="L330" title="1 of 4 branches missed.">            if (targetField.getFieldType() != null &amp;&amp; targetField.getFieldType() != FieldType.STRING) {</span>
<span class="fc" id="L331">                Validation validation = new Validation();</span>
<span class="fc" id="L332">                validation.setScope(ValidationScope.MAPPING);</span>
<span class="fc" id="L333">                validation.setId(mappingId);</span>
<span class="fc" id="L334">                validation.setMessage(String.format(</span>
                        &quot;Target field '%s' must be of type '%s' for a Combine Mapping&quot;,
<span class="fc" id="L336">                        getFieldName(targetField), FieldType.STRING));</span>
<span class="fc" id="L337">                validation.setStatus(ValidationStatus.ERROR);</span>
<span class="fc" id="L338">                validations.add(validation);</span>
            }
<span class="fc" id="L340">            validateField(mappingId, null, targetField, FieldDirection.TARGET, validations);</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        } else if (sourceFields != null) { // SOURCE</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">            for (Field sourceField : sourceFields) {</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">                if (matchDocIdOrNull(sourceField.getDocId())) {</span>
<span class="fc" id="L344">                    validateField(mappingId, null, sourceField, FieldDirection.SOURCE, validations);</span>
                }
<span class="fc" id="L346">            }</span>
        }
<span class="fc" id="L348">    }</span>

    @Deprecated
    protected void validateSeparateMapping(Mapping mapping, List&lt;Validation&gt; validations) {
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        if (mapping == null) {</span>
<span class="nc" id="L353">            return;</span>
        }

<span class="fc" id="L356">        final List&lt;Field&gt; sourceFields = mapping.getInputField();</span>
<span class="pc bpc" id="L357" title="2 of 4 branches missed.">        final Field sourceField = (sourceFields != null &amp;&amp; !sourceFields.isEmpty()) ? sourceFields.get(0) : null;</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        if (sourceField == null) {</span>
<span class="nc" id="L359">            return;</span>
        }
<span class="fc" id="L361">        List&lt;Field&gt; targetFields = mapping.getOutputField();</span>
<span class="fc" id="L362">        String mappingId = mapping.getId();</span>

<span class="pc bpc" id="L364" title="1 of 4 branches missed.">        if (getMode() == AtlasModuleMode.SOURCE &amp;&amp; matchDocIdOrNull(sourceField.getDocId())) {</span>
            // check that the source field is of type String else error
<span class="pc bpc" id="L366" title="1 of 4 branches missed.">            if (sourceField.getFieldType() != null &amp;&amp; sourceField.getFieldType() != FieldType.STRING) {</span>
<span class="fc" id="L367">                Validation validation = new Validation();</span>
<span class="fc" id="L368">                validation.setScope(ValidationScope.MAPPING);</span>
<span class="fc" id="L369">                validation.setId(mapping.getId());</span>
<span class="fc" id="L370">                validation.setMessage(String.format(</span>
                        &quot;Source field '%s' must be of type '%s' for a Separate Mapping&quot;,
<span class="fc" id="L372">                        getFieldName(sourceField), FieldType.STRING));</span>
<span class="fc" id="L373">                validation.setStatus(ValidationStatus.ERROR);</span>
<span class="fc" id="L374">                validations.add(validation);</span>
            }
<span class="fc" id="L376">            validateField(mappingId, null, sourceField, FieldDirection.SOURCE, validations);</span>

<span class="pc bpc" id="L378" title="1 of 2 branches missed.">            if (targetFields != null) {</span>
                // FIXME Run only for SOURCE to avoid duplicate validation...
                // we should convert per module validations to plugin style
<span class="fc bfc" id="L381" title="All 2 branches covered.">                for (Field targetField : targetFields) {</span>
<span class="fc" id="L382">                    mappingFieldPairValidator.validateFieldTypes(validations, mappingId, sourceField, targetField);</span>
<span class="fc" id="L383">                }</span>
            }
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">        } else if (targetFields != null) { // TARGET</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">            for (Field targetField : targetFields) {</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">                if (matchDocIdOrNull(targetField.getDocId())) {</span>
<span class="fc" id="L388">                    validateField(mappingId, null, targetField, FieldDirection.TARGET, validations);</span>
                }
<span class="fc" id="L390">            }</span>
        }
<span class="fc" id="L392">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>